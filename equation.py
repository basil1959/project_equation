import math

# метод вилки
# самый универсальный алгоритм поиска решения уравнения f(x) = 0
# сначала локализуем корень уравнения в пределах [a b] - это самое трудное в этом методе
# локализация корня состоит в нахождении отрезка на оси x, на концах которого 
# функция f(x) принимает разные знаки (больше ни о чем думать не надо)
# весь дальнейший процесс сводится к сужению области локализации до приемлего размера (например, до 0.00001)
# параметр z задает этот приемлемый разьер
# если на этом отрезке несколько корней, то найден будет ближайший к левому концу отрезка
# изменяя концы отрезка, можно искать остальные корни 
# (при этом, если f(x) достаточно сложная функция, некоторые из них могут "избежать" обнаружения)
# if(a1 * x**2 + a2 * math.sin(x) + a3 * math.cos(x)) * (a1 * x1**2 + a2 * math.sin(x1) + a3 * math.cos(x1)) > 0:

def equation(a, b, d):
    a1 = -1
    a2 = 1
    a3 = 1
    str_equation = f'{a1} * x**2 + {a2} * sin(x) + {a3} * cos(x) = 0'
    x1 = a
    x2 = b
    k1 = 0
    k2 = 0
    if a1 * x1**2 + a2 * math.sin(x1) + a3 * math.cos(x1) >= 0:
        k1 = 1
    else:
        k1 = -1

    if a1 * x2**2 + a2 * math.sin(x2) + a3 * math.cos(x2) >= 0:
        k2 = 1
    else:
        k2 = -1

    if k1 * k2 > 0:
       print(f'Значение функции при x = {round(x, 4)} равно {round(t, 4)}') 

    while abs(x1 - x2) > d:
        x = (x1 + x2) / 2
        if (a1 * x**2 + a2 * math.sin(x) + a3 * math.cos(x)) * k > 0:
            x1 = x
        else:
            x2 = x

    fin_val = a1 * x**2 + a2 * math.sin(x) + a3 * math.cos(x)

    print(f'Корень уравнения {str_equation} на отрезке [{a}  {b}] с точностью до {z} равен {round(x, 4)}')
    print(f'Значение функции при x = {round(x, 4)} равно {round(t, 4)}')


equation(-2*math.pi, 2*math.pi, 0.001)
